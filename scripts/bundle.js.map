{"version":3,"sources":["webpack:///webpack/bootstrap 7c90863221bdba1abaf4","webpack:///./scripts/entry.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa,cAAc;AACtC,gBAAgB,gBAAgB,mBAAmB;AACnD,gBAAgB,mBAAmB,gBAAgB;AACnD,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB,gCAAgC,wBAAwB,aAAa,OAAO,0BAA0B,yBAAyB,6BAA6B,6BAA6B,uCAAuC,gBAAgB;AACzR;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,KAAK;AACnB,cAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,KAAK;AACL;;AAEA;AACA;;;AAGA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7c90863221bdba1abaf4","// declare web audio api variables:\nlet audioContext;\nlet drumGainNode;\nlet synthGainNode;\nlet instrumentGain;\nlet dryGain;\nlet wetGain;\nlet feedback;\nlet compression;\nlet delay;\nlet clock;\nlet isPlaying = false;\n//store the file names of sounds to be used\nlet drumSounds = [\"hh1\", \"kick1\", \"snare1\"];\nlet synthSounds = [\n  \"s-asharp\", \"s-csharp\", \"s-csharplow\",\n  \"s-dsharp\", \"s-dsharplow\", \"s-fsharp\",\n  \"s-fsharphigh\", \"s-gsharp\"\n];\n//eventually we will store the decoded files in the buffers object\nlet buffers = {};\nlet tempo = 60;\nlet totalBeats = 16;\nlet beats = {\n  \"hh1\": {}, \"kick1\": {}, \"snare1\": {},\n  \"s-asharp\": {}, \"s-csharp\": {}, \"s-csharplow\": {},\n  \"s-dsharp\": {}, \"s-dsharplow\": {}, \"s-fsharp\": {},\n  \"s-fsharphigh\": {}, \"s-gsharp\": {}\n};\nlet allEvents = [];\nlet uiEvent;\nlet startTime;\nlet rhythmIndex = 1;\nlet noteTime = 0.0;\n// See https://github.com/cwilso/MIDIDrums for timerWorker info\nlet timerWorker = null;\nlet prevAnimTime = -1;\n\n\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  setupAudioContext();\n  setupClickHandlers();\n  setupSlideHandlers();\n\n  drumSounds.forEach( (sound) => {\n    loadDrumSound(sound);\n  });\n\n  synthSounds.forEach( (sound) => {\n    loadSynthSound(sound);\n  });\n\n  startWorker();\n\n});\n\n// timerWorker citation: https://github.com/cwilso/MIDIDrums\n// Chris Wilson is the WAA scheduling guru\n// we are using worker to call schedule()\nconst startWorker = () => {\n  let timerWorkerBlob = new Blob([\n    \"let timeoutID=0;function schedule(){timeoutID=setTimeout(function(){postMessage('schedule'); schedule();},100);} onmessage = function(e) { if (e.data == 'start') { if (!timeoutID) schedule();} else if (e.data == 'stop') {if (timeoutID) clearTimeout(timeoutID); timeoutID=0;};}\"\n  ]);\n\n  let timerWorkerBlobURL = window.URL.createObjectURL(timerWorkerBlob);\n\n  timerWorker = new Worker(timerWorkerBlobURL);\n  timerWorker.onmessage = (e) => {\n    schedule();\n  };\n  timerWorker.postMessage('init');\n};\n\n// Set up audio context, gain nodes for both drums and synth, and connect them\nconst setupAudioContext = () => {\n  const AudioContext = window.AudioContext || window.webkitAudioContext;\n  audioContext = new AudioContext();\n  drumGainNode = audioContext.createGain();\n  synthGainNode = audioContext.createGain();\n  instrumentGain = audioContext.createGain();\n  dryGain = audioContext.createGain();\n  wetGain = audioContext.createGain();\n  drumGainNode.connect(instrumentGain);\n  synthGainNode.connect(instrumentGain);\n  instrumentGain.connect(dryGain);\n  instrumentGain.connect(wetGain);\n  dryGain.gain.value = 1;\n  wetGain.gain.value = 0;\n  // ADD EFFECTS\n  dryGain.connect(audioContext.destination);\n  compression = audioContext.createDynamicsCompressor();\n  feedback = audioContext.createGain();\n  feedback.gain.value = 0.19;\n  delay = audioContext.createDelay();\n  delay.delayTime.value = 0.08;\n  wetGain.connect(compression);\n  compression.connect(delay);\n  delay.connect(feedback);\n  feedback.connect(delay);\n  delay.connect(audioContext.destination);\n};\n\nconst handlePlay = (e) => {\n  noteTime = 0.0;\n  startTime = audioContext.currentTime + 0.005;\n  schedule();\n  timerWorker.postMessage(\"start\");\n};\n\nconst handlePause = () => {\n  timerWorker.postMessage(\"stop\");\n  rhythmIndex = 1;\n  $(\".light\").removeClass(\"currently-playing\");\n\n};\n\nconst playNote = (sound, time) => {\n  let bufferNode = buffers[sound].createNode();\n  bufferNode.start(time);\n};\n\nconst schedule = () => {\n  let currentTime = audioContext.currentTime;\n  // The sequence starts at startTime, so normalize currentTime so that it's 0 at the start of the sequence.\n  // See: https://www.html5rocks.com/en/tutorials/audio/scheduling/\n  currentTime -= startTime;\n  while (noteTime < currentTime + 0.120) {\n    // Convert noteTime to context time.\n    let contextPlayTime = noteTime + startTime;\n\n    // Kick\n    if (beats[\"kick1\"][rhythmIndex]) {\n      playNote(\"kick1\", contextPlayTime);\n    }\n\n    // Snare\n    if (beats[\"snare1\"][rhythmIndex]) {\n        playNote(\"snare1\", contextPlayTime);\n    }\n\n    // Hihat\n    if (beats[\"hh1\"][rhythmIndex]) {\n        playNote(\"hh1\", contextPlayTime);\n    }\n\n    // // SYNTHS\n    if (beats[\"s-asharp\"][rhythmIndex]) {\n        playNote(\"s-asharp\", contextPlayTime);\n    }\n\n    if (beats[\"s-csharp\"][rhythmIndex]) {\n        playNote(\"s-csharp\", contextPlayTime);\n    }\n\n    if (beats[\"s-csharplow\"][rhythmIndex]) {\n        playNote(\"s-csharplow\", contextPlayTime);\n    }\n\n    if (beats[\"s-dsharp\"][rhythmIndex]) {\n        playNote(\"s-dsharp\", contextPlayTime);\n    }\n\n    if (beats[\"s-dsharplow\"][rhythmIndex]) {\n        playNote(\"s-dsharplow\", contextPlayTime);\n    }\n\n    if (beats[\"s-fsharp\"][rhythmIndex]) {\n        playNote(\"s-fsharp\", contextPlayTime);\n    }\n\n    if (beats[\"s-fsharphigh\"][rhythmIndex]) {\n        playNote(\"s-fsharphigh\", contextPlayTime);\n    }\n\n    if (beats[\"s-gsharp\"][rhythmIndex]) {\n        playNote(\"s-gsharp\", contextPlayTime);\n    }\n\n    // Light up the current beat\n    if (noteTime !== prevAnimTime) {\n        prevAnimTime = noteTime;\n        animateUi((rhythmIndex + 15) % 16 + 1);\n    }\n\n    //Increase current beat by one\n    nextNote();\n  }\n};\n\nconst animateUi = (beat) => {\n// Beats are 1 through 16, so, we do a bit of weird modding to get prevBeat\n  let prevBeat = (beat + 14) % 16 + 1;\n\n  $(`#light-${beat}`).addClass(\"currently-playing\");\n  $(`#light-${prevBeat}`).removeClass(\"currently-playing\");\n};\n\nconst nextNote = () => {\n  let beatTime = 60.0 / tempo;\n  rhythmIndex++;\n  if (rhythmIndex > totalBeats) {\n    rhythmIndex = 1;\n  }\n\n  noteTime += 0.25 * beatTime;\n};\n\nconst setupClickHandlers = () => {\n  //Nodes on the sequencer change color when clicked\n  //They also either activate or deactive their respective events\n  $(\".grid-node\").click( (e) => {\n    let $node = $(e.target);\n    let nodeBeat = $node.data(\"beat\");\n    let nodeSound = $node.data(\"sound\");\n    $node.toggleClass(\"clicked-node\");\n    $node.hasClass(\"clicked-node\") ?\n      activateNode(nodeBeat, nodeSound) : deactivateNode(nodeBeat, nodeSound);\n  });\n\n  //Start with the pause icon hidden and then toggle on click\n  $(\"#pause\").hide();\n  $(\"#play-button\").click( (e) => {\n    $(\"#play\").toggle();\n    $(\"#pause\").toggle();\n    isPlaying = !isPlaying;\n    // if the audio is paused or not playing, play it!\n    isPlaying ? handlePlay() : handlePause();\n  });\n\n  // Modal\n  // See: https://www.w3schools.com/howto/howto_css_modals.asp\n  let $modal = $(\"#modal\");\n  let $modalButton = $(\"#modal-button\");\n  let $span = $(\".close\");\n\n  $modalButton.click( (e) => {\n    $modal.css(\"display\", \"block\");\n  });\n\n  $span.click( (e) => {\n    $modal.css(\"display\", \"none\");\n  });\n\n  $(window).click( (e) => {\n    if (e.target == $modal[0]) {\n      $modal.css(\"display\", \"none\");\n    }\n  });\n\n  // Set up demo buttons\n  let $kickDemo = $(\"#kick-demo\");\n  let $snareDemo = $(\"#snare-demo\");\n  let $hhDemo = $(\"#hh-demo\");\n  let $lowFive = $(\"#low-five-demo\");\n  let $lowSix = $(\"#low-six-demo\");\n  let $oneDemo = $(\"#one-demo\");\n  let $twoDemo = $(\"#two-demo\");\n  let $threeDemo = $(\"#three-demo\");\n  let $fiveDemo = $(\"#five-demo\");\n  let $sixDemo = $(\"#six-demo\");\n  let $eightDemo = $(\"#eight-demo\");\n\n  $kickDemo.click( (e) => {\n    buffers[\"kick1\"].createNode().start(audioContext.currentTime);\n  });\n\n  $snareDemo.click( (e) => {\n    buffers[\"snare1\"].createNode().start(audioContext.currentTime);\n  });\n\n  $hhDemo.click( (e) => {\n    buffers[\"hh1\"].createNode().start(audioContext.currentTime);\n  });\n\n  $lowFive.click( (e) => {\n    buffers[\"s-csharplow\"].createNode().start(audioContext.currentTime);\n  });\n\n  $lowSix.click( (e) => {\n    buffers[\"s-dsharplow\"].createNode().start(audioContext.currentTime);\n  });\n\n  $oneDemo.click( (e) => {\n    buffers[\"s-fsharp\"].createNode().start(audioContext.currentTime);\n  });\n\n  $twoDemo.click( (e) => {\n    buffers[\"s-gsharp\"].createNode().start(audioContext.currentTime);\n  });\n\n  $threeDemo.click( (e) => {\n    buffers[\"s-asharp\"].createNode().start(audioContext.currentTime);\n  });\n\n  $fiveDemo.click( (e) => {\n    buffers[\"s-csharp\"].createNode().start(audioContext.currentTime);\n  });\n\n  $sixDemo.click( (e) => {\n    buffers[\"s-dsharp\"].createNode().start(audioContext.currentTime);\n  });\n\n  $eightDemo.click( (e) => {\n    buffers[\"s-fsharphigh\"].createNode().start(audioContext.currentTime);\n  });\n};\n\n// Schedule the node to play its sound on the given beat\n// Info about which notes are/should be scheduled is stored in beats\nconst activateNode = (beat, sound) => {\n  beats[sound][beat] = true;\n};\n\nconst deactivateNode = (beat, sound) => {\n  beats[sound][beat] = false;\n};\n\nconst setupSlideHandlers = () => {\n  // Display tempo upon slider value change and call changeTempo\n  // The numbers that val is divided by are just accounting for\n  // 1) what makes sense to display to user and 2) making sure changeTempo\n  // functions smoothly\n  const $tempoLabel = $(\"#tempo-value\");\n  const $tempoSlider = $(\"#tempo-slider\");\n  $tempoSlider.on(\"input change\", () => {\n    let val = $tempoSlider.val();\n    $tempoLabel.text(val/2);\n    changeTempo(val/4);\n  });\n\n  //Link drum and synth gains to their respective sliders\n  const $drumGainLabel = $(\"#drum-gain-value\");\n  const $drumGainSlider = $(\"#drum-gain-slider\");\n  $drumGainSlider.on(\"input\", () => {\n    let val = $drumGainSlider.val();\n    $drumGainLabel.text(val/10);\n    drumGainNode.gain.value = val / 110;\n  });\n\n  const $synthGainLabel = $(\"#synth-gain-value\");\n  const $synthGainSlider = $(\"#synth-gain-slider\");\n  $synthGainSlider.on(\"input\", () => {\n    let val = $synthGainSlider.val();\n    $synthGainLabel.text(val/10);\n    synthGainNode.gain.value = val / 110;\n  });\n\n  // Add magic sauce (basically slap-back delay, feedback, and compression)\n  const $magicSlideLabel = $(\"#magic-value\");\n  const $magicSlider = $(\"#magic-slider\");\n  $magicSlider.on(\"input\", () => {\n    let val = $magicSlider.val();\n    $magicSlideLabel.text(val);\n    wetGain.gain.value = val/2;\n    dryGain.gain.value = 1 - val/2;\n  });\n};\n\n// Since the scheduling function uses 'tempo' to schedule notes,\n// all we need to do here is set tempo to newTempo\nconst changeTempo = (newTempo) => {\n  tempo = newTempo;\n};\n\n// Load the drum sounds and connect them to drum node\n// See examples at https://github.com/sebpiq/WAAClock for reference\nconst loadDrumSound = (instrumentName) => {\n  const oReq = new XMLHttpRequest();\n  // Make an ajax request to fetch the audio ('true' indicates async)\n  // Can't use jQuery here bc it doesn't support ArrayBuffer response types\n  oReq.open('GET', 'https://raw.githubusercontent.com/ethannkschneider/ecto-drum/master/audio_files/' + instrumentName + \".mp3\", true);\n  oReq.responseType = 'arraybuffer';\n  // Once the request is loaded, decode the arraybuffer into an audiobuffer\n  // and pass it to the callback, which makes a createNode function to\n  // connect a bufferSource to the final destination of audioContext.\n  // We then store that particular createNode function in the buffers array\n  // so we can access it later.\n  oReq.onload = () => {\n    audioContext.decodeAudioData(oReq.response, (audioBuffer) => {\n      let createNode = function() {\n        let source = audioContext.createBufferSource();\n        source.buffer = audioBuffer;\n        source.connect(drumGainNode);\n        return source;\n      };\n      buffers[instrumentName] = { createNode };\n    });\n  };\n\n  // Actually send the request\n  oReq.send();\n};\n\n// Similar to above\nconst loadSynthSound = (instrumentName) => {\n  const oReq = new XMLHttpRequest();\n  oReq.open('GET', 'https://raw.githubusercontent.com/ethannkschneider/ecto-drum/master/audio_files/' + instrumentName + \".mp3\", true);\n  oReq.responseType = 'arraybuffer';\n\n  oReq.onload = () => {\n    audioContext.decodeAudioData(oReq.response, (audioBuffer) => {\n      let createNode = function() {\n        let source = audioContext.createBufferSource();\n        source.buffer = audioBuffer;\n        source.connect(synthGainNode);\n        return source;\n      };\n      buffers[instrumentName] = { createNode };\n    });\n  };\n\n  oReq.send();\n};\n\n\n// End of document\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./scripts/entry.js\n// module id = 0\n// module chunks = 0"],"sourceRoot":""}